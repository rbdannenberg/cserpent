require "src/frontend/file"
require "src/frontend/token"
require "src/frontend/utils"
require "src/frontend/parser"
require "src/frontend/parser_ctx"


def parse_ast(path):
    file = load_from_path(path)
    if file == nil:
        return err_res("file " + path + " cannot be opened", nil)
    
    tokens = tokenize(file)
    pretty_print_tokenize_result(tokens)

    if not tokens.ok:
        print "lex error:", file.get_formatted_pos(tokens.error.range.start)
        return tokens

    ctx = ParseContext(tokens.result)
    if not parse_global_decls(ctx):
        print "parse error:", file.get_formatted_pos(ctx.error.range.start)
        return Result(false, ctx.error)

    return res(ctx.pop_result())


class CompilationSession:

    var entry_point // main file
    var files // files[qualified_file_name] = file_ast
    var top_order // topological ordering of the files in the project

    def init():
        this.entry_point = nil
        this.files = {}
        this.top_order = []

    # call this to load the entry point of a project
    # returns `nil` on success, or error if otherwise
    def load_main_file(file_path):
        if this.entry_point != nil:
            return Error(
                nil,
                "compilation session already loaded " + this.entry_point
            )

        return this.load_and_parse_file(file_path, [])

    # used internally
    # returns `nil` on success, or error if otherwise
    def load_and_parse_file(file_path, loaded_stack):
        if file_path in loaded_stack:
            return Error(
                nil,
                "circular dependency, " + file_path + " is already included"
            )

        var result = parse_ast(file_path)
        if not result.ok:
            return result.error

        this.files[file_path] = result.result
        loaded_stack.append(file_path)

        for dep in result.result.deps:
            var dep_res = load_and_parse_file(dep, loaded_stack)
            if dep_res != nil:
                return dep_res

        loaded_stack.unappend()
        if file_path not in this.top_order:
            this.top_order.append(file_path)
            
        return nil

    def get_topological_ordering():
        return this.top_order
