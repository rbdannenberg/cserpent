require "parser_ctx"


### FIRST SETS ###

FS_EXPRESSION = [
    TK_LITERAL,
    TK_IDENTIFIER,
    "[",
    "{",
    "(",
    "-",
    "+",
    "not",
    "~"
]


### PRECEDENCE SYMBOLS ###

// TODO: handle "is not" and "not in"
PREC_TABLE = [
    ["or"],
    ["and"],
    ["<", "<=", "==", "!=", ">", ">=", "is", "in"],
    ["+", "-", "|", "^", "<<", ">>"],
    ["*", "/", "%", "&"],
    // `**` not included as it has higher associativity that prefix operators
]

PREFIX_TABLE = ["+", "-", "~", "not"]


### MISC CONSTRUCTS ###

def add_to_arg_lists(val, args, kwargs):
    if val[0] == [0]:
        args.append(val[1])
    else:
        kwargs[val[1][0]] = val[1][1]


# Return type: [type, value]
# type:
#   0: normal argument (value is just an AST of expression)
#   1: keyword argument (value is [Identifier, Expression])
def parse_arg_list_entry(ctx):
    if ctx.pos + 1 < len(ctx.input) and ctx.input[ctx.pos + 1].content == "=":
        if not ctx.skip_store(TK_IDENTIFIER): return false
        key = ctx.pop_partial().content
        if not ctx.skip("="): return false
        if not parse_expression(ctx): return false
        value = ctx.pop_result()
        ctx.set_result([1, [key, value]])
    else:
        if not parse_expression(ctx): return false
        ctx.set_result([0, ctx.pop_result()])

    return true


def parse_arg_list(ctx):
    args = []
    kwargs = {}
    if ctx.get(FS_EXPRESSION, false) != nil:
        if not parse_arg_list_entry(ctx): return false
        add_to_arg_lists(ctx.pop_result(), args, kwargs)

        while ctx.skip(",", false):
            if not parse_arg_list_entry(ctx): return false
            add_to_arg_lists(ctx.pop_result(), args, kwargs)

    ctx.set_result(ArgumentList(args, kwargs))
    return true


def parse_dict_entry(ctx):
    if not parse_expression(ctx): return false
    key = ctx.pop_result()
    if not ctx.skip(","): return false
    if not parse_expression(ctx): return false
    value = ctx.pop_result()

    ctx.set_result([key, value])
    return true


### EXPRESSIONS ###

def parse_inner(ctx):

    # array
    if ctx.skip("[", false):
        vals = []
        if ctx.get(FS_EXPRESSION, false) != nil:
            if not parse_expression(ctx): return false
            vals.append(ctx.pop_result())

            while ctx.skip(",", false):
                if not parse_expression(ctx): return false
                vals.append(ctx.pop_result())

        if not ctx.skip("]"): return false
        res = Array(vals)

    # dict
    elif ctx.skip("{", false):
        vals = []
        if ctx.get(FS_EXPRESSION, false) != nil:
            if not parse_dict_entry(ctx): return false
            vals.append(ctx.pop_result())

            while ctx.skip(",", false):
                if not parse_dict_entry(ctx): return false
                vals.append(ctx.pop_result())

        if not ctx.skip("}"): return false
        res = Dictionary(vals)
    
    # literal
    elif ctx.skip_store(TK_LITERAL, false):
        // TODO: object_type
        res = Literal(ctx.pop_partial().content, nil)

    # identifier
    elif ctx.skip_store(TK_IDENTIFIER, false):
        iden = ctx.pop_partial().content
        if ctx.skip("(", false):
            if not parse_arg_list(ctx): return false
            res = FunctionCall(iden, ctx.pop_result())
            if not ctx.skip(")"): return false
        else:
            res = Identifier(iden)

    # parenthesized expression
    elif ctx.skip("(", false):
        if not parse_expression(ctx): return false
        if not ctx.skip(")"): return false
        res = ctx.pop_result()

    else:
        ctx.err_fset_miss([TK_LITERAL, TK_IDENTIFIER, "[", "{", "("])
        return false

    # postfix constructs
    while ctx.skip_store([".", "["], false):
        fst = ctx.pop_partial().content
        if fst == ".":
            if not ctx.skip_store(TK_IDENTIFIER): return false
            iden = ctx.pop_partial().content
            if ctx.skip("(", false):
                if not parse_arg_list(ctx): return false
                res = MethodCall(res, iden, ctx.pop_result())
                if not ctx.skip(")"): return false
            else:
                res = GetAttribute(res, iden)
        else:
            if not parse_expression(ctx): return false
            res = Index(res, ctx.pop_result())
            if not ctx.skip("]"): return false

    ctx.set_result(res)
    return true


def parse_exponent(ctx):
    if not parse_inner(ctx): return false
    ast = ctx.pop_result()

    while ctx.skip("**", false):
        if not parse_inner(ctx): return false
        rhs = ctx.pop_result()
        ast = BinOp(ast, "**", rhs)
    
    ctx.set_result(ast)
    return true


def parse_term(ctx):
    precs = []
    while ctx.skip_store(PREFIX_TABLE, false):
        precs.append(ctx.pop_partial())

    if not parse_exponent(ctx): return false
    inner = ctx.pop_result()
    for i = len(prec - 1) to -1 by -1:
        inner = UnaryOp(precs[i].content, inner)
    
    ctx.set_result(inner)
    return true


def parse_infix(ctx, level = 0):

    # If at end of recorded precedence table, use the term parser instead.
    if level == len(PREC_TABLE):
        return parse_term(ctx)
    
    pred = PREC_TABLE[level]
    if not parse_infix(ctx, level + 1): return false
    ast = ctx.pop_result()

    while ctx.skip_store(pred, false):
        symbol = ctx.pop_partial()
        if not parse_infix(ctx, level + 1): return false
        rhs = ctx.pop_result()
        ast = BinOp(ast, symbol.content, rhs)
    
    ctx.set_result(ast)
    return true


def parse_expression(ctx):
    return parse_infix(ctx)
