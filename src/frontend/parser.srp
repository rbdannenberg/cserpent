require "parser_ctx"


### FIRST SETS ###

FS_EXPRESSION = [
    TK_LITERAL,
    TK_IDENTIFIER,
    "[",
    "{",
    "(",
    "-",
    "+",
    "not",
    "~"
]


### PRECEDENCE SYMBOLS ###

// TODO: handle "is not" and "not in"
PREC_TABLE = [
    ["or"],
    ["and"],
    ["<", "<=", "==", "!=", ">", ">=", "is", "in"],
    ["+", "-", "|", "^", "<<", ">>"],
    ["*", "/", "%", "&"],
    // `**` not included as it has higher associativity that prefix operators
]

PREFIX_TABLE = ["+", "-", "~", "not"]


### MISC CONSTRUCTS ###

def parse_arg_list(ctx):
    pass = 1


### EXPRESSIONS ###

def parse_postfix(ctx):
    pass = 1


def parse_inner(ctx):

    # TODO: dict and array
    
    # literal
    if ctx.skip_store(TK_LITERAL, false):
        // TODO: object_type
        res = Literal(ctx.pop_partial().content, nil)

    # identifier
    elif ctx.skip_store(TK_IDENTIFIER, false):
        iden = ctx.pop_partial().content
        if ctx.skip("(", false):
            if not parse_arg_list(ctx): return false
            res = FunctionCall(iden, ctx.pop_result())
            if not ctx.skip(")"): return false
        else:
            res = Identifier(iden)

    # parenthesized expression
    elif ctx.skip("(", false):
        if not parse_expression(ctx): return false
        if not ctx.skip(")"): return false
        res = ctx.pop_result()

    else:
        ctx.err_fset_miss([TK_LITERAL, TK_IDENTIFIER, "[", "{", "("])
        return false

    while ctx.skip_store([".", "["], false):
        fst = ctx.pop_partial().content
        if fst == ".":
            if not ctx.skip_store(TK_IDENTIFIER): return false
            iden = ctx.pop_partial().content
            if ctx.skip("(", false):
                if not parse_arg_list(ctx): return false
                res = MethodCall(res, iden, ctx.pop_result())
                if not ctx.skip(")"): return false
            else:
                res = GetAttribute(res, iden)
        else:
            if not parse_expression(ctx): return false
            res = Index(res, ctx.pop_result())
            if not ctx.skip("]"): return false

    ctx.set_result(res)
    return true


def parse_exponent(ctx):
    if not parse_inner(ctx): return false
    ast = ctx.pop_result()

    while ctx.skip("**", false):
        if not parse_inner(ctx): return false
        rhs = ctx.pop_result()
        ast = BinOp(ast, "**", rhs)
    
    ctx.set_result(ast)
    return true


def parse_term(ctx):
    precs = []
    while ctx.skip_store(PREFIX_TABLE, false):
        precs.append(ctx.pop_partial())

    if not parse_exponent(ctx): return false
    inner = ctx.pop_result()
    for i = len(prec - 1) to -1 by -1:
        inner = UnaryOp(precs[i].content, inner)
    
    ctx.set_result(inner)
    return true


def parse_infix(ctx, level = 0):

    # If at end of recorded precedence table, use the term parser instead.
    if level == len(PREC_TABLE):
        return parse_term(ctx)
    
    pred = PREC_TABLE[level]
    if not parse_infix(ctx, level + 1): return false
    ast = ctx.pop_result()

    while ctx.skip_store(pred, false):
        symbol = ctx.pop_partial()
        if not parse_infix(ctx, level + 1): return false
        rhs = ctx.pop_result()
        ast = BinOp(ast, symbol.content, rhs)
    
    ctx.set_result(ast)
    return true


def parse_expression(ctx):
    return parse_infix(ctx)
