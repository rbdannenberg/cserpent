require "src/backend/visitor.srp"
require "src/frontend/ast.srp"

function_corrections = {
    "main": "main__",
    "str": "force_str",
    "int": "force_int"

}

class CodegenVisitor(ASTVisitor):
    var output_folder
    var source_lines
    var header_lines
    var main_lines
    var main_includes
    var curr_code_line
    var indent_levels
    var include_list
    var user_defined_classes
    var global_variables
    var current_class
    # enums
    var source
    var header
    var main

    def init(_output_folder):
        super.init()
        output_folder = _output_folder
        source_lines = []
        header_lines = []
        main_lines = ["int main() {"]
        main_includes = []
        curr_code_line = ""
        indent_levels = [0, 0, 1]
        context = 1
        include_list =
            "#pragma once\n" +
            "#include <runtime.h>\n"
        indentation = "    "
        user_defined_classes = []
        global_variables = {}
        source = 0
        header = 1
        main = 2

    def reset():
        source_lines = []
        header_lines = []
        curr_code_line = ""
        indent_levels = [0, 0, 1]

    def switch_context(ctx):
        context = ctx

    def add_line(line, optional ctx = nil):
        if ctx == nil:
            ctx = context
        for i = 0 to indent_levels[ctx]:
            line = indentation + line
        if ctx == 0:
            source_lines.append(line)
        elif ctx == 1:
            header_lines.append(line)
        else:
            main_lines.append(line)

    def visitLiteral(literal):
        # print literal.value, type(literal.value), isstring(literal.value)
        if literal.value[0] == "\"":
            curr_code_line = curr_code_line + "String {" + str(literal.value) + "}"
        elif literal.value[0] == "'":
            curr_code_line = curr_code_line + "Symbol {\"" + subseq(str(literal.value), 1, -1) + "\"}"
        else:
            curr_code_line = curr_code_line + str(literal.value)

    def visitIdentifier(identifier):
        if current_class and identifier.value in current_class.member_variables:
            curr_code_line = curr_code_line + "get_" + identifier.value + "()"
            return
        curr_code_line = curr_code_line + identifier.value
        global_variables[identifier.value] = "variable"


    def visitBoolOp(bool_op):
        bool_op.left.accept(this)
        curr_code_line = curr_code_line + " " + bool_op.op + " "
        bool_op.right.accept(this)

    def visitBinOp(bin_op):
        var function_correction = nil
        if bin_op.op == "**":
            function_correction = "pow"
        if bin_op.op == "is":
            function_correction = "is_equal"
        if function_correction:
            curr_code_line = curr_code_line + function_correction + "("
            bin_op.left.accept(this)
            curr_code_line = curr_code_line + ", "
            bin_op.right.accept(this)
            curr_code_line = curr_code_line + ")"
            return
        bin_op.left.accept(this)
        curr_code_line = curr_code_line + " " + bin_op.op + " "
        bin_op.right.accept(this)

    def visitUnaryOp(unary_op):
        curr_code_line = curr_code_line + unary_op.op
        unary_op.value.accept(this)

    def visitArray(array_node):
        # array literal, adds a 
        curr_code_line = curr_code_line + "*(new Array {"
        for element at i in array_node.elements:
            element.accept(this)
            if i < len(array_node.elements) - 1:
                curr_code_line = curr_code_line + ", "
        curr_code_line = curr_code_line + "})"

    def visitDictionary(dictionary_node):
        curr_code_line = curr_code_line + "*(new Dictionary {"
        for pair at i in dictionary.pairs:
            curr_code_line = curr_code_line + "{"
            pair[0].accept(this)
            curr_code_line = curr_code_line + ", "
            pair[1].accept(this)
            curr_code_line = curr_code_line + "}"

            if i < len(dictionary.pairs) - 1:
                curr_code_line = curr_code_line + ", "
        curr_code_line = curr_code_line + "})"

    def visitArgumentList(argument_list):
        var kwargs = argument_list.kwargs
        if len(argument_list.args) == 0 and argument_list.dispatch == "dynamic":
            curr_code_line = curr_code_line + "empty_array"
        else:
            if argument_list.dispatch == "dynamic":
                curr_code_line = curr_code_line + "Array {"

            for i = 0 to len(argument_list.args):
                argument_list.args[i].accept(this)
                if i < len(argument_list.args) - 1
                    curr_code_line = curr_code_line + ", "

            if argument_list.dispatch == "dynamic":
                curr_code_line = curr_code_line + "}"

        if argument_list.dispatch == "dynamic" or len(kwargs.keys()) > 0:
            if len(kwargs.keys()) == 0:
                curr_code_line = curr_code_line + ", empty_dict"
            else:
                curr_code_line = curr_code_line + ", Dictionary {"
                for i = 0 to len(kwargs.keys()):
                    curr_code_line = curr_code_line + "{"
                    key = kwargs.keys()[i]
                    key.accept(this)
                    curr_code_line = curr_code_line + ", "
                    kwargs[key].accept(this)
                    curr_code_line = curr_code_line + "}"
                    if i < len(kwargs) - 1:
                        curr_code_line = curr_code_line + ", "
                curr_code_line = curr_code_line + "}"

    def visitFunctionCall(function_call):
        if function_call.name in user_defined_classes:
            visitConstructor(function_call)
            return
        if function_call.name in function_corrections.keys():
            function_call.name = function_corrections[function_call.name]
        var args = function_call.parameters.args
        if function_call.name == "print":
            curr_code_line = curr_code_line + "std::cout << "
            if len(function_call.parameters.kwargs) != 0:
                print "Error: print function does not take keyword arguments"
                exit()
            for i = 0 to len(args):
                args[i].accept(this)
                if i < len(args) - 1
                    curr_code_line = curr_code_line + " << \" \" << "
            curr_code_line = curr_code_line + " << std::endl"
        elif function_call.name == "exit":
            curr_code_line = curr_code_line + "exit(0)"
        elif function_call.name == "funcall":
            curr_code_line = curr_code_line + "apply("
            function_call.parameters.args[0].accept(this)
            curr_code_line = curr_code_line + ", *(new Array {"
            for i = 1 to len(args):
                args[i].accept(this)
                if i < len(args) - 1
                    curr_code_line = curr_code_line + ", "
            curr_code_line = curr_code_line + "}))"
        elif function_call.name == "send":
            curr_code_line = curr_code_line + "sendapply("
            function_call.parameters.args[0].accept(this)
            curr_code_line = curr_code_line + ", "
            function_call.parameters.args[1].accept(this)
            curr_code_line = curr_code_line + ", *(new Array {"
            for i = 2 to len(args):
                args[i].accept(this)
                if i < len(args) - 1
                    curr_code_line = curr_code_line + ", "
            curr_code_line = curr_code_line + "}))"

        else:
            curr_code_line = curr_code_line + function_call.name + "("
            function_call.parameters.accept(this)
            curr_code_line = curr_code_line + ")"

    def visitConstructor(constructor):
        curr_code_line = curr_code_line + "*(new " + constructor.name + " {"
        constructor.parameters.accept(this)
        curr_code_line = curr_code_line + "})"

    def visitMethodCall(method_call):
        method_call.object.accept(this)
        curr_code_line = curr_code_line + ".call(\"" + method_call.method_name + "\", "
        method_call.parameters.dispatch = "dynamic"
        method_call.parameters.accept(this)
        curr_code_line = curr_code_line + ")"

    def visitGetAttribute(get_attribute):
        get_attribute.object.accept(this)
        curr_code_line = curr_code_line + ".call(\"get_" + get_attribute.attribute + "\", empty_array, empty_dict)"

    def visitIndex(index):
        index.object.accept(this)
        curr_code_line = curr_code_line + "["
        index.index.accept(this)
        curr_code_line = curr_code_line + "]"

    def visitAssignment(assignment):
        if isinstance(assignment.identifier, GetAttribute):
            get_attribute = assignment.identifier
            get_attribute.object.accept(this)
            curr_code_line = curr_code_line + ".call(\"set_" + get_attribute.attribute + "\", Array {"
            assignment.expression.accept(this)
            add_line(curr_code_line + "}, empty_dict);")
            curr_code_line = ""
            return
        # same goes for index
        if current_class and isinstance(assignment.identifier, Identifier) and assignment.identifier.value in current_class.member_variables:
            if curr_code_line != "":
                print "Should be empty, weird"
            curr_code_line = "set_" + assignment.identifier.value + "("
            assignment.expression.accept(this)
            add_line(curr_code_line + ");")
            return
        assignment.identifier.accept(this)
        curr_code_line = curr_code_line + " = "
        assignment.expression.accept(this)
        add_line(curr_code_line + ";")
        curr_code_line = ""

    def visitStandaloneExpression(standalone_expression):
        standalone_expression.expression.accept(this)
        add_line(curr_code_line + ";")
        curr_code_line = ""

    def visitDeclaration(declaration):
        add_line(declaration.declared_type + " " + declaration.identifier.value + ";")

    def visitDeclarationNAssignment(declaration_n_assignment):
        # we don't use the declared type for now because we are using Any
        // declaration_n_assignment.identifier.accept(this)
        curr_code_line = curr_code_line + + declaration_n_assignment.identifier + " = "
        declaration_n_assignment.expression.accept(this)
        add_line("Any " + curr_code_line + ";")
        curr_code_line = ""

    def visitReturnStatement(return_statement):
        curr_code_line = "return "
        return_statement.expression.accept(this)
        add_line(curr_code_line + ";")
        curr_code_line = ""

    def visitBlock(block):
        add_line("{")
        indent_levels[context] = indent_levels[context] + 1
        for statement in block.statements:
            statement.accept(this)
        indent_levels[context] = indent_levels[context] - 1
        add_line("}")

    def visitIf(if_statement):
        curr_code_line = "if ("
        if_statement.condition.accept(this)
        curr_code_line = curr_code_line + ")"
        add_line(curr_code_line)
        curr_code_line = ""
        if_statement.block.accept(this)
        if if_statement.else_block is not nil:
            add_line("else")
            if_statement.else_block.accept(this)

    def visitWhile(while_statement):
        curr_code_line = "while ("
        while_statement.condition.accept(this)
        curr_code_line = curr_code_line + ")"
        add_line(curr_code_line)
        curr_code_line = ""
        while_statement.block.accept(this)

    def visitForRange(for_statement):
        curr_code_line = "for (int64_t " + for_statement.identifier + " = "
        for_statement.start.accept(this)
        curr_code_line = curr_code_line + "; " + for_statement.identifier + " < "
        for_statement.end.accept(this)
        curr_code_line = curr_code_line + "; " + for_statement.identifier + " += ";
        for_statement.by_amount.accept(this)
        curr_code_line = curr_code_line + ")"
        add_line(curr_code_line)
        curr_code_line = ""
        for_statement.block.accept(this)

    def visitForEach(for_statement):
        curr_code_line = "for (auto " + for_statement.identifier.value + " : "
        for_statement.iterable.accept(this)
        curr_code_line = curr_code_line + ")"
        add_line(curr_code_line)
        curr_code_line = ""
        for_statement.block.accept(this)


    def visitFunction(function):
        num_args = len(function.positional)
        if function.name == "main":
            function.name = "main__"

        # collect arguments within the parentheses
        curr_code_line = function.name + "("
        for i = 0 to num_args:
            curr_code_line = curr_code_line + "Any " + function.positional[i] # Change this once type inference exists
            if i < num_args - 1:
                curr_code_line = curr_code_line + ", "
        curr_code_line = curr_code_line + ")"

        var global_line = "Any " + "global_" + function.name + "(const Array& args, const Dictionary& kwargs)"

        add_line("Any " + curr_code_line + ";", header)
        if current_class:
            add_line("Any " + current_class.name + "::" + curr_code_line, source)
        else:
            add_line("Any " + curr_code_line, source)



        curr_code_line = ""
        # make corrections to the block
        var last_statement = function.block.statements.last()
        if not isinstance(last_statement, ReturnStatement):
            if isinstance(last_statement, StandaloneExpression):
                function.block.statements[len(function.block.statements) - 1] = ReturnStatement(last_statement.expression)
            else:
                function.block.statements.append(ReturnStatement(Literal("nil", "Any")))
        switch_context(source)
        function.block.accept(this)
        switch_context(header)

        if not current_class:
            # function is global
            add_line(global_line + ";", header)
            add_line(global_line + " {", source)
            add_line(indentation + "check_dispatch(\"" + function.name + "\", args, kwargs, " + str(len(function.positional)) + ", " + str(len(function.optional)) + ");", source)
            var call = indentation + "return " + function.name + "("
            for i = 0 to num_args:
                call = call + "args[" + str(i) + "]"
                if i < num_args - 1:
                    call = call + ", "
            call = call + ");"
            add_line(call, source)
            add_line("}", source)
            add_line("globals::cs_symbol_table.set_function(Symbol {\"" + function.name + "\"}, &global_" + function.name + ");", main)

    def visitClass(class_):
        current_class = class_
        user_defined_classes.append(class_.name)
        switch_context(header)
        var class_ptr = class_.name + "_class"
        var function_list = []
        add_line("extern Cs_class * " + class_ptr + ";")
        print "here1", context
        add_line("class " + class_.name + " : public Obj {")
        add_line("public:")
        indent_levels[context] = indent_levels[context] + 1
        add_line("Any more_slots[" + str(len(class_.member_variables)) + "];")
        add_line(class_.name + "() : Obj {" + class_ptr + "} {}")

        for variable at index in class_.member_variables:
            var variable_str = variable
            var getter = "get_" + variable_str
            var setter = "set_" + variable_str
            
            add_line("Any " + getter + "() {")
            add_line(indentation + "return slots[" + str(index + 1) + "];") # since slot 0 is for class pointer
            add_line("}")
            add_line("Any " + setter + "(Any value) {")
            add_line(indentation + "set_slot(" + str(index + 1) + ", value);")
            add_line(indentation + "return nil;")
            add_line("}")

            function_list.append([getter, 0, 0])
            function_list.append([setter, 1, 0])


        for function in class_.member_functions:

            function.accept(this)
            function_list.append([function.name, len(function.positional), len(function.optional)])
            if function.name == "init":
                var num_args = len(function.positional)
                var enclosed = ""

                curr_code_line = class_.name + "("
                for i = 0 to num_args:
                    curr_code_line = curr_code_line + "Any " + function.positional[i] # Change this once type inference exists
                    enclosed = enclosed + function.positional[i]
                    if i < num_args - 1:
                        curr_code_line = curr_code_line + ", "
                        enclosed = enclosed + ", "
                curr_code_line = curr_code_line + ") : Obj {" + class_ptr + "} {"
                add_line(curr_code_line)
                add_line(indentation + "init(" + enclosed + ");")
                add_line("}")

        indent_levels[context] = indent_levels[context] - 1
        add_line("};")

        # Define global functions for each class member function
        switch_context(source)
        for function in function_list:
            var function_name = function[0]
            var signature = "Any " + class_.name + "_" + function_name + "(Obj* self, const Array& args, const Dictionary& kwargs)"
            add_line(signature + ";", header)
            add_line(signature + " {", source)
            indent_levels[context] = indent_levels[context] + 1
            add_line("check_dispatch(\"" + function_name + "\", args, kwargs," + str(function[1]) + "," + str(function[2]) + ");")
            var dispatch_line = "reinterpret_cast<" + class_.name + "*>(self)->" + function_name + "("
            for i = 0 to function[1]:
                dispatch_line = dispatch_line + "args[" + str(i) + "]"
                if i < function[1] - 1:
                    dispatch_line = dispatch_line + ", "
            dispatch_line = dispatch_line + ");"
            add_line("return " + dispatch_line)
            indent_levels[context] = indent_levels[context] - 1
            add_line("}")

        # Create the MemberTable that maps symbols to function pointers
        var table_name = "MemberTable " + class_.name + "_table"
        add_line("extern " + table_name + ";", header)
        add_line(table_name + " {", source)
        indent_levels[context] = indent_levels[context] + 1
        for function in function_list:
            add_line("{Symbol{\"" + function[0] + "\"}, " + class_.name + "_" + function[0] + "},")
        indent_levels[context] = indent_levels[context] - 1
        add_line("};")

        # NOTE: 0b0 should be changed once type inference is implemented and we have pointer types
        var cs_class_init = "{Symbol {\"" + class_.name + "\"}, " + str(len(class_.member_variables)) + ", 0b0, &" + class_.name + "_table};"
        add_line("Cs_class * " + class_ptr + " = new Cs_class " + cs_class_init)
        switch_context(header)
        current_class = nil

    def visitFile(file):
        add_line(include_list)
        for element in file.elements:
            if isinstance(element, Class) or isinstance(element, Function):
                context = 1
            else:
                context = 2
            element.accept(this)


    def generate_main(folder, ast):
        main_lines.append(indentation + "return 0;")
        main_lines.append("}")
        var main_file = open(output_folder + "/main.cpp", "w")
        for line in main_includes:
            main_file.write(line + "\n")
        for global_variable in global_variables.keys():
            main_file.write("Any " + global_variable + ";\n")
        for line in main_lines:
            main_file.write(line + "\n")
        main_file.close()

    def generate_code(filename, ast, keyword main):
        reset()
        ast.accept(this)
        var source_file = open(output_folder + "/" + filename + ".cpp", "w")
        source_file.write("#include \"" + filename + ".h\"\n\n")
        for line in source_lines:
            source_file.write(line + "\n")
        var header_file = open(output_folder + "/" + filename + ".h", "w")
        for line in header_lines:
            header_file.write(line + "\n")
        source_file.close()
        header_file.close()
        if main:
            main_includes.append("#include \"" + filename + ".h\"")
            generate_main(filename, ast)
        else:
            print "Not implemented yet"
        reset()




